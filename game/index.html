<!DOCTYPE html>

<html lang="zh-TW">

<head>

    <meta charset="UTF-8">

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>五乘五賽車挑戰</title>

    <script src="https://cdn.tailwindcss.com"></script>

    <style>

        body { background-color: #f1f5f9; touch-action: manipulation; }

        /* 防止手機雙擊縮放 */

    </style>

    

    <script type="importmap">

    {

      "imports": {

        "react": "https://esm.sh/react@18.2.0",

        "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",

        "lucide-react": "https://esm.sh/lucide-react@0.263.1"

      }

    }

    </script>

    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

</head>

<body>

    <div id="root"></div>



    <script type="text/babel" data-type="module">

        import React, { useState, useEffect, useRef } from 'react';

        import { createRoot } from 'react-dom/client';

        import { Play, RotateCcw, Flag, ArrowRight, RefreshCw, Trophy, Lightbulb } from 'lucide-react';



        const GRID_SIZE = 5;

        const SPEED_MS = 300;

        const DIRECTIONS = [

          { dx: 0, dy: -1, label: 'N' },

          { dx: 1, dy: 0, label: 'E' },

          { dx: 0, dy: 1, label: 'S' },

          { dx: -1, dy: 0, label: 'W' },

        ];



        const CarSideIcon = ({ className, style }) => (

          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" className={className} style={style}>

            <path d="M2 10 V 15 H 4.5 C 4.5 13.6 5.6 12.5 7 12.5 C 8.4 12.5 9.5 13.6 9.5 15 H 14.5 C 14.5 13.6 15.6 12.5 17 12.5 C 18.4 12.5 19.5 13.6 19.5 15 H 22 V 11.5 L 18 11.5 L 16 7 H 6 L 2 10 Z" fill="currentColor" stroke="currentColor" strokeWidth="1" strokeLinejoin="round"/>

            <path d="M7 8 H 15 L 16.5 10.5 H 6.5 L 7 8 Z" fill="white" fillOpacity="0.9" />

            <rect x="21" y="12" width="1.5" height="2" rx="0.5" fill="#FCD34D" />

            <circle cx="7" cy="15" r="2.5" fill="#1F2937" />

            <circle cx="7" cy="15" r="1" fill="#9CA3AF" />

            <circle cx="17" cy="15" r="2.5" fill="#1F2937" />

            <circle cx="17" cy="15" r="1" fill="#9CA3AF" />

          </svg>

        );



        const simulatePath = (start, goal, placedCards) => {

          let car = { ...start };

          let steps = 0;

          const maxSteps = GRID_SIZE * GRID_SIZE * 4; 

          while (steps < maxSteps) {

            const dirVec = DIRECTIONS[car.dir];

            const nextX = car.x + dirVec.dx;

            const nextY = car.y + dirVec.dy;

            if (nextX < 0 || nextX >= GRID_SIZE || nextY < 0 || nextY >= GRID_SIZE) return false;

            car.x = nextX; car.y = nextY;

            if (car.x === goal.x && car.y === goal.y) return true;

            const card = placedCards.find(c => c.x === car.x && c.y === car.y);

            if (card) {

              if (card.type === 'red') car.dir = (car.dir + 1) % 4;

              else if (card.type === 'blue') car.dir = (car.dir + 3) % 4;

            }

            steps++;

          }

          return false;

        };



        const getRandomInt = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;



        const generateMustPassLevel = () => {

          let attempts = 0;

          while (attempts < 3000) {

            attempts++;

            const start = { x: getRandomInt(0, 4), y: getRandomInt(0, 4), dir: getRandomInt(0, 3) };

            let turnsNeeded = ['red', 'red', 'blue', 'blue'];

            for (let i = turnsNeeded.length - 1; i > 0; i--) {

              const j = Math.floor(Math.random() * (i + 1));

              [turnsNeeded[i], turnsNeeded[j]] = [turnsNeeded[j], turnsNeeded[i]];

            }

            let current = { ...start };

            let path = [{ x: current.x, y: current.y }];

            let turnPositions = [];

            let isValidPath = true;

            let visitedSet = new Set([`${start.x},${start.y}`]); 

            for (let i = 0; i <= turnsNeeded.length; i++) {

              const steps = getRandomInt(1, 3);

              const dirVec = DIRECTIONS[current.dir];

              for (let s = 0; s < steps; s++) {

                current.x += dirVec.dx; current.y += dirVec.dy;

                if (current.x < 0 || current.x >= GRID_SIZE || current.y < 0 || current.y >= GRID_SIZE) { isValidPath = false; break; }

                const key = `${current.x},${current.y}`;

                if (visitedSet.has(key)) { isValidPath = false; break; }

                visitedSet.add(key);

                path.push({ x: current.x, y: current.y });

              }

              if (!isValidPath) break;

              if (i < turnsNeeded.length) {

                const turnType = turnsNeeded[i];

                turnPositions.push({ x: current.x, y: current.y, type: turnType });

                if (turnType === 'red') current.dir = (current.dir + 1) % 4;

                else current.dir = (current.dir + 3) % 4;

              }

            }

            if (!isValidPath) continue;

            const goal = { x: current.x, y: current.y };

            if (turnPositions.some(t => t.x === goal.x && t.y === goal.y)) continue;

            const candidates = path.slice(1, -1).filter(p => !turnPositions.some(t => t.x === p.x && t.y === p.y));

            if (candidates.length < 3) continue;

            const uniqueCandidates = [...new Set(candidates.map(c => JSON.stringify(c)))].map(s => JSON.parse(s));

            if (uniqueCandidates.length < 3) continue;

            const yellows = [];

            const tempCandidates = [...uniqueCandidates];

            for(let i=0; i<3; i++) {

               const idx = getRandomInt(0, tempCandidates.length - 1);

               yellows.push(tempCandidates[idx]);

               tempCandidates.splice(idx, 1);

            }

            return {

              id: `mp-${Date.now()}`,

              start, goal, yellows,

              inventory: { red: 2, blue: 2 },

              preset: [],

              solution: turnPositions,

              description: "請使用2紅2藍，通過3個黃色檢查點，抵達綠色終點。",

              winCondition: (v, t) => v === t

            };

          }

          return generateMustPassLevel(); 

        };



        const generateRemoveCardLevel = () => {

          let attempts = 0;

          while (attempts < 5000) {

            attempts++;

            const start = { x: getRandomInt(0, 4), y: getRandomInt(0, 4), dir: getRandomInt(0, 3) };

            const isCaseA = Math.random() > 0.5;

            const pattern = isCaseA ? { red: 3, blue: 2 } : { red: 2, blue: 3 };

            const trapType = isCaseA ? 'blue' : 'red'; 

            let turnsToPlace = [];

            for(let i=0; i<pattern.red; i++) turnsToPlace.push('red');

            for(let i=0; i<pattern.blue; i++) turnsToPlace.push('blue');

            for (let i = turnsToPlace.length - 1; i > 0; i--) {

              const j = Math.floor(Math.random() * (i + 1));

              [turnsToPlace[i], turnsToPlace[j]] = [turnsToPlace[j], turnsToPlace[i]];

            }

            let current = { ...start };

            let pathCells = [{x: start.x, y: start.y}]; 

            let placedCards = []; 

            let isValidPath = true;

            let visitedSet = new Set([`${start.x},${start.y}`]);

            for (let i = 0; i <= turnsToPlace.length; i++) {

               const steps = getRandomInt(1, 3);

               const dirVec = DIRECTIONS[current.dir];

               for(let s=0; s<steps; s++) {

                  current.x += dirVec.dx; current.y += dirVec.dy;

                  if (current.x < 0 || current.x >= GRID_SIZE || current.y < 0 || current.y >= GRID_SIZE) { isValidPath = false; break; }

                  const key = `${current.x},${current.y}`;

                  if (visitedSet.has(key)) { isValidPath = false; break; }

                  visitedSet.add(key);

                  pathCells.push({x: current.x, y: current.y});

               }

               if(!isValidPath) break;

               if (i < turnsToPlace.length) {

                 const type = turnsToPlace[i];

                 placedCards.push({ x: current.x, y: current.y, type });

                 if (type === 'red') current.dir = (current.dir + 1) % 4;

                 else current.dir = (current.dir + 3) % 4;

               }

            }

            if (!isValidPath) continue;

            const goal = { x: current.x, y: current.y };

            if (start.x === goal.x && start.y === goal.y) continue;

            if (placedCards.some(c => c.x === goal.x && c.y === goal.y)) continue;

            const candidates = pathCells.filter(p => !(p.x === start.x && p.y === start.y) && !(p.x === goal.x && p.y === goal.y) && !placedCards.some(c => c.x === p.x && c.y === p.y));

            if (candidates.length === 0) continue;

            const uniqueCandidates = [...new Set(candidates.map(c => JSON.stringify(c)))].map(s => JSON.parse(s));

            const trapPos = uniqueCandidates[getRandomInt(0, uniqueCandidates.length - 1)];

            const trap = { x: trapPos.x, y: trapPos.y, type: trapType };

            const finalPreset = [...placedCards, trap];

            if (simulatePath(start, goal, finalPreset)) continue; 

            if (!simulatePath(start, goal, placedCards)) continue;

            return {

                id: `rc-${Date.now()}`,

                start, goal, yellows: [],

                inventory: { red: 0, blue: 0 },

                preset: finalPreset,

                solution: trap,

                description: "請移除路徑上多餘的卡片，讓車子抵達綠色終點。",

                winCondition: () => true,

                maxRemovals: 1

            };

          }

          return generateRemoveCardLevel();

        };



        function CarLogicGame() {

          const [mode, setMode] = useState('must_pass');

          const [currentLevel, setCurrentLevel] = useState(null);

          const [grid, setGrid] = useState([]);

          const [car, setCar] = useState(null);

          const [isPlaying, setIsPlaying] = useState(false);

          const [gameStatus, setGameStatus] = useState('idle');

          const [message, setMessage] = useState('');

          const [visitedYellows, setVisitedYellows] = useState([]);

          const [placedCounts, setPlacedCounts] = useState({ red: 0, blue: 0 });

          const [selectedTool, setSelectedTool] = useState('red');

          const [removedCount, setRemovedCount] = useState(0);

          const timerRef = useRef(null);

          const lastProcessedPos = useRef({ x: -1, y: -1 });

          const carRef = useRef(null);

          const visitedRef = useRef(visitedYellows);

          const gridRef = useRef(grid);

          const levelRef = useRef(currentLevel);



          useEffect(() => { carRef.current = car; }, [car]);

          useEffect(() => { visitedRef.current = visitedYellows; }, [visitedYellows]);

          useEffect(() => { gridRef.current = grid; }, [grid]);

          useEffect(() => { levelRef.current = currentLevel; }, [currentLevel]);

          useEffect(() => { generateNewLevel(); }, [mode]);



          const generateNewLevel = () => {

              let level;

              if (mode === 'must_pass') level = generateMustPassLevel();

              else level = generateRemoveCardLevel();

              setCurrentLevel(level);

          };



          useEffect(() => { if (currentLevel) resetGridState(); }, [currentLevel]);



          const resetGridState = () => {

            if (!currentLevel) return;

            const newGrid = Array(GRID_SIZE * GRID_SIZE).fill(null).map((_, i) => {

              const x = i % GRID_SIZE; const y = Math.floor(i / GRID_SIZE);

              const preset = currentLevel.preset.find(p => p.x === x && p.y === y);

              const isYellow = currentLevel.yellows.find(p => p.x === x && p.y === y);

              const isStart = currentLevel.start.x === x && currentLevel.start.y === y;

              const isGoal = currentLevel.goal.x === x && currentLevel.goal.y === y;

              return { x, y, type: preset ? preset.type : (isYellow ? 'yellow' : 'empty'), isStart, isGoal, originalType: preset ? preset.type : (isYellow ? 'yellow' : 'empty') };

            });

            setGrid(newGrid);

            setCar({ ...currentLevel.start });

            carRef.current = { ...currentLevel.start }; 

            setIsPlaying(false);

            setGameStatus('idle');

            setMessage('');

            setVisitedYellows([]);

            setPlacedCounts({ red: 0, blue: 0 });

            setRemovedCount(0);

            lastProcessedPos.current = { x: -1, y: -1 };

            if (timerRef.current) clearInterval(timerRef.current);

          };



          const endGame = (status, msg) => {

            clearInterval(timerRef.current);

            setIsPlaying(false);

            setGameStatus(status);

            setMessage(msg);

          };



          const moveCar = () => {

            const prevCar = carRef.current;

            if (!prevCar) return;

            const currentDir = DIRECTIONS[prevCar.dir];

            const nextX = prevCar.x + currentDir.dx;

            const nextY = prevCar.y + currentDir.dy;

            if (nextX < 0 || nextX >= GRID_SIZE || nextY < 0 || nextY >= GRID_SIZE) { endGame('lost', "哎呀！車子撞到牆壁了！"); return; }

            const nextCar = { ...prevCar, x: nextX, y: nextY };

            setCar(nextCar);

          };



          const showAnswer = () => {

            if (!currentLevel) return;

            if (isPlaying) { 

                clearInterval(timerRef.current); setIsPlaying(false); setGameStatus('idle'); setCar({ ...currentLevel.start }); carRef.current = { ...currentLevel.start };

                lastProcessedPos.current = { x: -1, y: -1 }; setVisitedYellows([]); 

            }

            if (mode === 'must_pass') {

              const newGrid = grid.map(cell => ({ ...cell, type: cell.originalType === 'yellow' ? 'yellow' : 'empty' }));

              currentLevel.solution.forEach(sol => { const index = sol.y * GRID_SIZE + sol.x; newGrid[index].type = sol.type; });

              setGrid(newGrid);

              setPlacedCounts(currentLevel.inventory);

              setMessage("已顯示參考答案");

            } else if (mode === 'remove_card') {

              const newGrid = grid.map(cell => ({ ...cell, type: cell.originalType }));

              const sol = currentLevel.solution;

              const index = sol.y * GRID_SIZE + sol.x;

              newGrid[index].type = 'empty';

              setGrid(newGrid);

              setRemovedCount(1);

              setMessage("已顯示參考答案");

            }

          };



          const handleCellClick = (index) => {

            if (isPlaying || gameStatus !== 'idle') return;

            const cell = grid[index];

            const newGrid = [...grid];

            if (cell.isStart || cell.isGoal) return;



            if (mode === 'must_pass') {

              if (cell.type === 'yellow') { setMessage("檢查點不能覆蓋！"); return; }

              if (cell.type !== 'empty') {

                const typeToRemove = cell.type;

                newGrid[index].type = 'empty';

                setPlacedCounts(prev => ({ ...prev, [typeToRemove]: prev[typeToRemove] - 1 }));

              } else {

                if (placedCounts[selectedTool] < currentLevel.inventory[selectedTool]) {

                  newGrid[index].type = selectedTool;

                  setPlacedCounts(prev => ({ ...prev, [selectedTool]: prev[selectedTool] + 1 }));

                } else { setMessage(`您的卡片用完了！`); }

              }

            } else if (mode === 'remove_card') {

              if (cell.originalType === 'red' || cell.originalType === 'blue') {

                if (cell.type === 'empty') {

                  newGrid[index].type = cell.originalType;

                  setRemovedCount(prev => prev - 1);

                } else {

                  if (removedCount < currentLevel.maxRemovals) {

                    newGrid[index].type = 'empty';

                    setRemovedCount(prev => prev + 1);

                  } else { setMessage("只能移除一張！"); }

                }

              }

            }

            setGrid(newGrid);

          };



          const startGame = () => {

            if (mode === 'must_pass') {

              if (placedCounts.red !== currentLevel.inventory.red || placedCounts.blue !== currentLevel.inventory.blue) { setMessage("請先放完所有卡片！"); return; }

            }

            if (mode === 'remove_card') { if (removedCount !== 1) { setMessage("請移除一張卡片！"); return; } }

            lastProcessedPos.current = { x: -1, y: -1 };

            setIsPlaying(true); setGameStatus('running'); setMessage('車子出發了！');

            timerRef.current = setInterval(moveCar, SPEED_MS);

          };



          useEffect(() => {

            if (!isPlaying || !car || !currentLevel) return;

            if (car.x === lastProcessedPos.current.x && car.y === lastProcessedPos.current.y) return;

            lastProcessedPos.current = { x: car.x, y: car.y };

            const currentCell = grid.find(c => c.x === car.x && c.y === car.y);

            if (!currentCell) return;

            if (currentCell.isGoal) {

              const win = currentLevel.winCondition(visitedRef.current.length, currentLevel.yellows.length);

              if (win) endGame('won', "恭喜！成功抵達終點！");

              else endGame('lost', `失敗：只過了 ${visitedRef.current.length} 個檢查點！`);

              return;

            }

            if (currentCell.type === 'yellow') {

                const id = `${car.x},${car.y}`;

                if (!visitedRef.current.includes(id)) setVisitedYellows(prev => [...prev, id]);

            }

            if (currentCell.type === 'red') setCar(prev => ({ ...prev, dir: (prev.dir + 1) % 4 }));

            else if (currentCell.type === 'blue') setCar(prev => ({ ...prev, dir: (prev.dir + 3) % 4 }));

          }, [car, isPlaying, grid, currentLevel]);



          const getCarStyle = (dirIndex) => {

            const transition = 'transform 0.3s ease-in-out';

            if (dirIndex === 3) return { transform: 'scaleX(-1)', transition };

            if (dirIndex === 1) return { transform: 'rotate(0deg)', transition };

            const deg = (dirIndex - 1) * 90;

            return { transform: `rotate(${deg}deg)`, transition };

          };

          const getStartArrowRotation = () => currentLevel ? (currentLevel.start.dir - 1) * 90 : 0;



          if (!currentLevel) return <div className="min-h-screen flex items-center justify-center">載入中...</div>;



          return (

            <div className="min-h-screen bg-slate-100 p-2 font-sans text-slate-800 flex flex-col items-center justify-start">

              <div className="max-w-xs w-full mb-2 text-center">

                <h1 className="text-xl font-bold text-slate-800 mb-1 flex items-center justify-center gap-2">

                  <Trophy className="w-5 h-5 text-amber-500" /> 五乘五賽車挑戰

                </h1>

                <div className="mb-2 bg-white p-2 rounded-lg shadow-sm border border-slate-200">

                   <div className="flex flex-col gap-1 text-[10px] text-slate-600 font-medium">

                     <div className="flex justify-center gap-4">

                        <div className="flex items-center gap-1"><div className="w-3 h-3 border-2 border-slate-900 rounded flex items-center justify-center"><ArrowRight className="w-2 h-2" /></div> 起點</div>

                        <div className="flex items-center gap-1"><div className="w-3 h-3 border-2 border-green-500 rounded"></div> 終點</div>

                     </div>

                     <div className="flex justify-center gap-3">

                        <div className="flex items-center gap-1"><div className="w-3 h-3 bg-red-400 rounded"></div> 右轉</div>

                        <div className="flex items-center gap-1"><div className="w-3 h-3 bg-blue-400 rounded"></div> 左轉</div>

                        <div className="flex items-center gap-1"><div className="w-3 h-3 bg-amber-300 rounded"></div> 檢查點</div>

                     </div>

                   </div>

                </div>

                <div className="flex bg-white rounded-lg p-0.5 shadow-sm mb-2">

                  <button onClick={() => setMode('must_pass')} className={`flex-1 py-1.5 px-2 rounded-md text-xs font-medium transition-colors ${mode === 'must_pass' ? 'bg-indigo-600 text-white' : 'text-slate-500 hover:bg-slate-50'}`}>必經之路</button>

                  <button onClick={() => setMode('remove_card')} className={`flex-1 py-1.5 px-2 rounded-md text-xs font-medium transition-colors ${mode === 'remove_card' ? 'bg-indigo-600 text-white' : 'text-slate-500 hover:bg-slate-50'}`}>移除卡片</button>

                </div>

                <div className="bg-white p-2 rounded-lg shadow-sm border border-slate-200 min-h-[40px] flex flex-col justify-center relative overflow-hidden">

                  <div className="absolute top-0 right-0 p-0.5"><div className="bg-slate-100 text-slate-400 text-[8px] px-1 rounded">ID: {currentLevel.id.slice(-4)}</div></div>

                  <p className="text-xs text-slate-700 font-medium leading-tight px-1">{currentLevel.description}</p>

                </div>

              </div>

              <div className="relative bg-white p-3 rounded-xl shadow-lg border border-slate-200 w-full max-w-xs">

                <div className={`h-6 mb-1 text-center font-bold text-xs flex items-center justify-center rounded transition-colors ${gameStatus === 'won' ? 'text-green-600 bg-green-50' : gameStatus === 'lost' ? 'text-red-600 bg-red-50' : 'text-indigo-600'}`}>

                  {message || (mode === 'must_pass' ? `放置: ${currentLevel.inventory.red}紅 ${currentLevel.inventory.blue}藍` : "請移除 1 張卡片...")}

                </div>

                <div className="grid gap-1 bg-slate-300 p-1 rounded mb-2 mx-auto" style={{ gridTemplateColumns: `repeat(${GRID_SIZE}, minmax(0, 1fr))`, width: '100%', maxWidth: '280px', aspectRatio: '1/1' }}>

                  {grid.map((cell, idx) => (

                    <div key={`${cell.x}-${cell.y}`} onClick={() => handleCellClick(idx)} className={`relative rounded flex items-center justify-center cursor-pointer transition-all duration-200 aspect-square ${cell.type === 'red' ? 'bg-red-400' : cell.type === 'blue' ? 'bg-blue-400' : cell.type === 'yellow' ? 'bg-amber-300' : 'bg-white'} ${cell.isStart ? 'ring-2 ring-inset ring-slate-900' : ''} ${cell.isGoal ? 'ring-2 ring-inset ring-green-500' : ''}`}>

                      {cell.type === 'yellow' && <div className={`w-2.5 h-2.5 rounded-full ${visitedYellows.includes(`${cell.x},${cell.y}`) ? 'bg-green-600' : 'bg-amber-600'}`} />}

                      {cell.isStart && <ArrowRight className="text-slate-900 w-1/2 h-1/2 absolute opacity-40" style={{ transform: `rotate(${getStartArrowRotation()}deg)` }} />}

                      {cell.isGoal && <Flag className="text-green-600 w-2/3 h-2/3 absolute bottom-1 right-1 opacity-80" />}

                      {car && car.x === cell.x && car.y === cell.y && (<div className="absolute inset-0 z-10 flex items-center justify-center" style={getCarStyle(car.dir)}><CarSideIcon className="w-4/5 h-4/5 text-indigo-700 fill-current drop-shadow-md" /></div>)}

                    </div>

                  ))}

                </div>

                <div className="flex flex-col gap-2">

                  <div className="min-h-[50px] flex flex-col justify-center">

                    {mode === 'must_pass' && (

                      <div className="flex justify-center gap-4">

                        <button onClick={() => setSelectedTool('red')} className={`flex items-center gap-2 px-3 py-1 rounded border transition-all ${selectedTool === 'red' ? 'border-red-500 bg-red-50' : 'border-slate-200'}`}><div className="bg-red-400 w-3 h-3 rounded"></div><span className="text-xs font-bold text-slate-600">x {currentLevel.inventory.red - placedCounts.red}</span></button>

                        <button onClick={() => setSelectedTool('blue')} className={`flex items-center gap-2 px-3 py-1 rounded border transition-all ${selectedTool === 'blue' ? 'border-blue-500 bg-blue-50' : 'border-slate-200'}`}><div className="bg-blue-400 w-3 h-3 rounded"></div><span className="text-xs font-bold text-slate-600">x {currentLevel.inventory.blue - placedCounts.blue}</span></button>

                      </div>

                    )}

                    {mode === 'remove_card' && (<div className="flex justify-center items-center h-full"><div className="text-center text-xs text-slate-500 bg-slate-50 px-3 py-1 rounded border border-slate-200">已移除: <span className="font-bold text-indigo-600">{removedCount}</span> / 1</div></div>)}

                  </div>

                  <div className="flex flex-col gap-2 border-t pt-2">

                    <button onClick={startGame} disabled={isPlaying || gameStatus === 'won'} className="w-full bg-indigo-600 hover:bg-indigo-700 disabled:bg-slate-300 text-white py-2 px-4 rounded-lg flex items-center justify-center gap-2 font-bold shadow-sm text-sm"><Play className="w-4 h-4" /> 出發</button>

                    <div className="flex gap-2">

                        <button onClick={resetGridState} className="flex-1 bg-white border border-slate-300 text-slate-700 py-2 px-2 rounded-lg flex items-center justify-center gap-1 font-bold text-xs"><RotateCcw className="w-3 h-3" /> 重置</button>

                        <button onClick={showAnswer} className="flex-1 bg-white border border-slate-300 text-slate-700 py-2 px-2 rounded-lg flex items-center justify-center gap-1 font-bold text-xs"><Lightbulb className="w-3 h-3" /> 看答案</button>

                    </div>

                    <button onClick={generateNewLevel} className="w-full bg-amber-100 text-amber-800 py-2 px-3 rounded-lg flex items-center justify-center gap-2 font-bold shadow-sm mt-1 text-xs"><RefreshCw className="w-3 h-3" /> 下一題 (隨機)</button>

                  </div>

                </div>

              </div>

            </div>

          );

        }



        const root = createRoot(document.getElementById('root'));

        root.render(<CarLogicGame />);

    </script>

</body>

</html>